// scripts/generateAmenityIcons.mjs
// Generates src/data/amenityIcons.generated.ts from files in /public/icons
// Cross-platform (works on Windows + Vercel/Linux). Run via: node scripts/generateAmenityIcons.mjs

import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const ICONS_DIR = path.join(ROOT, "public", "icons");
const OUT_FILE = path.join(ROOT, "src", "data", "amenityIcons.generated.ts");

const exts = new Set([".png", ".jpg", ".jpeg", ".webp", ".svg"]);

function safeReadDir(dir) {
  try {
    return fs.readdirSync(dir, { withFileTypes: true });
  } catch {
    return [];
  }
}

function normalizeKey(input) {
  return String(input || "")
    .toLowerCase()
    .replace(/[’‘]/g, "'")
    .replace(/24\s*x\s*7/g, "24x7")
    .replace(/[^a-z0-9\s']/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function snakeToKey(fileBase) {
  return normalizeKey(String(fileBase || "").replace(/[_-]+/g, " "));
}

function addKey(map, key, val) {
  if (!key) return;
  const k = normalizeKey(key);
  if (!k) return;
  if (map[k]) return; // don't overwrite: first match wins
  map[k] = val;
}

/** Create extra aliases for better matching with real-world amenity labels. */
function addAliases(map, baseKey, val) {
  const k = normalizeKey(baseKey);

  // Basic aliases
  addKey(map, k.replace(/\barea\b/g, ""), val);
  addKey(map, k.replace(/\bplay\b/g, "play area"), val);

  // Common phrasing tweaks
  addKey(map, k.replace(/\bgymnasium\b/g, "gym"), val);
  addKey(map, k.replace(/\bswimming pool\b/g, "pool"), val);
  addKey(map, k.replace(/\bchildren\b/g, "kids"), val);

  // Common "track" phrasing
  addKey(map, k.replace(/\bjogging\b/g, "walking"), val);

  // Security variants
  if (k.includes("security")) {
    addKey(map, "24x7 security", val);
    addKey(map, "24 7 security", val);
    addKey(map, "cctv", val);
  }
}

function walkIcons(dir, rel = "") {
  const entries = safeReadDir(dir);
  const out = [];
  for (const e of entries) {
    const abs = path.join(dir, e.name);
    const nextRel = path.join(rel, e.name);
    if (e.isDirectory()) {
      out.push(...walkIcons(abs, nextRel));
    } else if (e.isFile()) {
      const ext = path.extname(e.name).toLowerCase();
      if (exts.has(ext)) out.push({ abs, rel: nextRel, ext });
    }
  }
  return out;
}

const iconFiles = walkIcons(ICONS_DIR);
const iconMap = {};

// Seed with your "core" file names even if users keep them generic.
// (If these files exist, the generator will include them anyway; this just adds extra keys.)
const core = [
  ["clubhouse", "/icons/clubhouse.png"],
  ["gym", "/icons/gym.png"],
  ["gymnasium", "/icons/gym.png"],
  ["swimming", "/icons/swimming.png"],
  ["swimming pool", "/icons/swimming.png"],
  ["pool", "/icons/swimming.png"],
  ["kids", "/icons/kids.png"],
  ["kids play area", "/icons/kids.png"],
  ["security", "/icons/security.png"],
  ["24x7 security", "/icons/security.png"],
  ["tennis", "/icons/tennis.png"],
  ["spa", "/icons/spa.png"],
  ["yoga", "/icons/yoga.png"],
];

for (const [k, v] of core) addKey(iconMap, k, v);

for (const f of iconFiles) {
  const base = path.basename(f.rel, f.ext); // filename without extension
  const webPath = "/" + path.posix.join("icons", f.rel.split(path.sep).join("/")); // force web path

  // Derive key from filename (snake -> spaces)
  const key = snakeToKey(base);
  addKey(iconMap, key, webPath);
  addAliases(iconMap, key, webPath);

  // Also add raw base (in case filenames are already spaced)
  addKey(iconMap, base, webPath);
  addAliases(iconMap, base, webPath);
}

// Ensure output directory exists
fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });

// Emit TS file
const header = `// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
// Generated by scripts/generateAmenityIcons.mjs
// Source: /public/icons
`;

const content =
  header +
  `const AMENITY_ICONS: Record<string, string> = ${JSON.stringify(iconMap, null, 2)};\n\n` +
  `export default AMENITY_ICONS;\n`;

fs.writeFileSync(OUT_FILE, content, "utf8");
console.log(`✅ Generated ${Object.keys(iconMap).length} icon keys -> ${path.relative(ROOT, OUT_FILE)}`);
